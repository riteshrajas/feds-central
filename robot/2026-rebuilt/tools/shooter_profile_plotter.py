#!/usr/bin/env python3
"""
Shooter Profile 3D Map Visualizer
==================================
Reads  shooter_profile.csv  generated by the Java ShooterProfiler and
produces four publication-quality plots:

  1. 3D scatter plot  â€” field XY position â†’ Z = distance to hub,
       color = launch velocity (reveals the pattern!)
  2. 2D heatmap       â€” optimal launch velocity per grid cell (min that scores)
  3. 2D heatmap       â€” optimal hood angle  per grid cell (angle for min-vel shot)
  4. 2D heatmap       â€” shot robustness (how many combos score â€” wider = more forgiving)

Usage
-----
  # From project root:
  python tools/shooter_profile_plotter.py

  # Or with a specific CSV path:
  python tools/shooter_profile_plotter.py path/to/shooter_profile.csv

  # High-res export only (no interactive window):
  python tools/shooter_profile_plotter.py --no-show

Output files (saved next to the CSV):
  shooter_profile_3d.png
  heatmap_velocity.png
  heatmap_angle.png
  heatmap_count.png
"""

import sys
import os
import argparse
import numpy as np
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 â€” registers 3D projection

# â”€â”€ Field geometry (must match ShooterProfiler.java) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FIELD_LENGTH_M = 16.4592
FIELD_WIDTH_M  =  8.2296
HUB_CENTER_X   =  1.6510
HUB_CENTER_Y   =  4.1148
HUB_INNER_RADIUS = 0.5296  # for drawing hub circle on 2D plots

# â”€â”€ Style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DARK_BG  = "#0e1117"
PANEL_BG = "#1a1d27"
ACCENT   = "#5865f2"
GRID_CLR = "#2a2d3a"
TEXT_CLR = "#e0e0e0"

def style_axis(ax, dark=True):
    """Apply dark theme to a 2D axis."""
    if dark:
        ax.set_facecolor(PANEL_BG)
        ax.tick_params(colors=TEXT_CLR, labelsize=8)
        ax.xaxis.label.set_color(TEXT_CLR)
        ax.yaxis.label.set_color(TEXT_CLR)
        ax.title.set_color(TEXT_CLR)
        for spine in ax.spines.values():
            spine.set_edgecolor(GRID_CLR)
        ax.grid(color=GRID_CLR, linewidth=0.5, linestyle="--", alpha=0.5)


def draw_field_overlay(ax, alpha=0.6):
    """Draw field boundary and hub marker on a 2D axes."""
    # Field border
    rect = mpatches.FancyBboxPatch(
        (0, 0), FIELD_LENGTH_M, FIELD_WIDTH_M,
        boxstyle="square,pad=0", linewidth=1.5,
        edgecolor="#ffffff", facecolor="none", alpha=alpha)
    ax.add_patch(rect)
    # Hub circle
    hub = plt.Circle((HUB_CENTER_X, HUB_CENTER_Y), HUB_INNER_RADIUS,
                      color="#ff6b35", linewidth=1.5, fill=False, alpha=alpha, label="Hub opening")
    ax.add_patch(hub)
    ax.plot(HUB_CENTER_X, HUB_CENTER_Y, "o", color="#ff6b35", markersize=4, alpha=alpha)


def load_csv(csv_path: str) -> pd.DataFrame:
    print(f"Loading {csv_path} â€¦")
    df = pd.read_csv(csv_path)
    print(f"  Loaded {len(df):,} successful shots")
    print(f"  Columns: {list(df.columns)}")
    print(f"  Distance range: {df['distance_m'].min():.2f} â€“ {df['distance_m'].max():.2f} m")
    print(f"  Velocity range: {df['velocity_mps'].min():.1f} â€“ {df['velocity_mps'].max():.1f} m/s")
    print(f"  Angle range:    {df['hood_angle_deg'].min():.1f} â€“ {df['hood_angle_deg'].max():.1f}Â°")
    return df


def build_grid(df: pd.DataFrame, grid_step: float = 0.25):
    """
    For every (robot_x, robot_y) grid cell, compute:
      - min_velocity : minimum launch velocity that scores from this cell
      - opt_angle   : hood angle corresponding to the min-velocity shot
      - count       : total number of (angle, vel) combos that score
    """
    grouped = df.groupby(["robot_x_m", "robot_y_m"])
    rows = []
    for (rx, ry), group in grouped:
        idx_min_vel = group["velocity_mps"].idxmin()
        rows.append({
            "rx": rx, "ry": ry,
            "min_vel": group.loc[idx_min_vel, "velocity_mps"],
            "opt_angle": group.loc[idx_min_vel, "hood_angle_deg"],
            "count": len(group),
            "distance": group["distance_m"].iloc[0],
        })
    grid = pd.DataFrame(rows)
    return grid


def plot_3d_scatter(df: pd.DataFrame, out_path: str, show: bool):
    """3D scatter: field XY â†’ Z = distance, color = velocity."""
    print("Generating 3D scatter â€¦")
    fig = plt.figure(figsize=(14, 9), facecolor=DARK_BG)
    ax = fig.add_subplot(111, projection="3d")
    ax.set_facecolor(PANEL_BG)

    # Subsample if huge (keep plot responsive)
    sample = df if len(df) <= 200_000 else df.sample(n=200_000, random_state=42)

    sc = ax.scatter(
        sample["robot_x_m"],
        sample["robot_y_m"],
        sample["distance_m"],
        c=sample["velocity_mps"],
        cmap="plasma",
        s=1,
        alpha=0.35,
        linewidths=0,
    )

    cbar = fig.colorbar(sc, ax=ax, pad=0.1, shrink=0.6)
    cbar.set_label("Launch Velocity (m/s)", color=TEXT_CLR, fontsize=10)
    cbar.ax.yaxis.set_tick_params(color=TEXT_CLR)
    plt.setp(plt.getp(cbar.ax.axes, "yticklabels"), color=TEXT_CLR)

    ax.set_xlabel("Robot X (m)", color=TEXT_CLR, fontsize=9, labelpad=8)
    ax.set_ylabel("Robot Y (m)", color=TEXT_CLR, fontsize=9, labelpad=8)
    ax.set_zlabel("Distance to Hub (m)", color=TEXT_CLR, fontsize=9, labelpad=8)
    ax.set_title("Shooter Profile â€” All Successful Shots\n(color = launch velocity)",
                 color=TEXT_CLR, fontsize=13, pad=12)
    ax.tick_params(colors=TEXT_CLR, labelsize=7)
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False
    ax.xaxis.pane.set_edgecolor(GRID_CLR)
    ax.yaxis.pane.set_edgecolor(GRID_CLR)
    ax.zaxis.pane.set_edgecolor(GRID_CLR)

    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches="tight", facecolor=DARK_BG)
    print(f"  Saved: {out_path}")
    if show:
        plt.show()
    plt.close()


def plot_3d_params(df: pd.DataFrame, out_path: str, show: bool):
    """
    3D scatter: X = Distance to Hub, Y = Hood Angle, Z = Launch Velocity.
    Each point is one successful shot. Color = density (how many combos share
    that distance band), making the mandatory shooting envelope pop out clearly.
    """
    print("Generating 3D params plot (Velocity vs Angle vs Distance) â€¦")

    # Subsample to keep rendering snappy
    sample = df if len(df) <= 150_000 else df.sample(n=150_000, random_state=7)

    fig = plt.figure(figsize=(14, 9), facecolor=DARK_BG)
    ax = fig.add_subplot(111, projection="3d")
    ax.set_facecolor(PANEL_BG)

    sc = ax.scatter(
        sample["distance_m"],
        sample["hood_angle_deg"],
        sample["velocity_mps"],
        c=sample["distance_m"],   # color by distance so near/far shots have distinct hues
        cmap="plasma",
        s=0.8,
        alpha=0.25,
        linewidths=0,
    )

    # Overlay the optimal frontier (min-velocity envelope) as a bold line
    # Group by distance bucket â†’ pick the minimum velocity shot
    bins = np.arange(df["distance_m"].min(), df["distance_m"].max() + 0.25, 0.25)
    df["dist_bin"] = pd.cut(df["distance_m"], bins=bins, labels=bins[:-1])
    frontier = (
        df.groupby("dist_bin", observed=True)
        .apply(lambda g: g.loc[g["velocity_mps"].idxmin()], include_groups=False)
        .reset_index(drop=True)
        .dropna(subset=["distance_m"])
        .sort_values("distance_m")
    )
    ax.plot(
        frontier["distance_m"],
        frontier["hood_angle_deg"],
        frontier["velocity_mps"],
        color="#00ffe0",
        linewidth=2.5,
        label="Optimal frontier (min velocity)",
        zorder=10,
    )

    cbar = fig.colorbar(sc, ax=ax, pad=0.1, shrink=0.55)
    cbar.set_label("Distance to Hub (m)", color=TEXT_CLR, fontsize=10)
    cbar.ax.yaxis.set_tick_params(color=TEXT_CLR)
    plt.setp(plt.getp(cbar.ax.axes, "yticklabels"), color=TEXT_CLR)

    ax.set_xlabel("Distance to Hub (m)", color=TEXT_CLR, fontsize=10, labelpad=10)
    ax.set_ylabel("Hood Angle (Â°)",       color=TEXT_CLR, fontsize=10, labelpad=10)
    ax.set_zlabel("Launch Velocity (m/s)",color=TEXT_CLR, fontsize=10, labelpad=10)
    ax.set_title(
        "Shooter Parameter Space â€” Velocity vs Hood Angle vs Distance\n"
        "(cyan line = minimum-velocity optimal frontier)",
        color=TEXT_CLR, fontsize=13, pad=14,
    )
    ax.tick_params(colors=TEXT_CLR, labelsize=7)
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False
    ax.xaxis.pane.set_edgecolor(GRID_CLR)
    ax.yaxis.pane.set_edgecolor(GRID_CLR)
    ax.zaxis.pane.set_edgecolor(GRID_CLR)
    ax.legend(loc="upper left", facecolor=PANEL_BG, labelcolor=TEXT_CLR, fontsize=9)

    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches="tight", facecolor=DARK_BG)
    print(f"  Saved: {out_path}")
    if show:
        plt.show()
    plt.close()


def plot_2d_heatmap(grid: pd.DataFrame, column: str, title: str, cbar_label: str,
                    cmap: str, out_path: str, show: bool):
    """Generic 2D heatmap over (robot_x, robot_y) for a given column."""
    print(f"Generating heatmap: {column} â€¦")

    # Pivot to 2D grid
    pivot = grid.pivot(index="ry", columns="rx", values=column)
    X = pivot.columns.values
    Y = pivot.index.values
    Z = pivot.values

    fig, ax = plt.subplots(figsize=(13, 7), facecolor=DARK_BG)
    style_axis(ax)

    im = ax.pcolormesh(X, Y, Z, cmap=cmap, shading="auto")
    cbar = fig.colorbar(im, ax=ax, pad=0.02)
    cbar.set_label(cbar_label, color=TEXT_CLR, fontsize=10)
    cbar.ax.yaxis.set_tick_params(color=TEXT_CLR)
    plt.setp(plt.getp(cbar.ax.axes, "yticklabels"), color=TEXT_CLR)

    draw_field_overlay(ax, alpha=0.8)
    ax.set_xlim(0, FIELD_LENGTH_M)
    ax.set_ylim(0, FIELD_WIDTH_M)
    ax.set_xlabel("Robot X â€” Blue Wall â†’ Red Wall (m)", color=TEXT_CLR, fontsize=10)
    ax.set_ylabel("Robot Y (m)", color=TEXT_CLR, fontsize=10)
    ax.set_title(title, color=TEXT_CLR, fontsize=13)
    ax.set_aspect("equal")
    ax.legend(handles=[mpatches.Patch(color="#ff6b35", label="Hub opening")],
              loc="upper right", facecolor=PANEL_BG, labelcolor=TEXT_CLR, fontsize=8)

    # Annotate hub center
    ax.annotate("Hub", (HUB_CENTER_X, HUB_CENTER_Y), color="#ff6b35",
                fontsize=8, ha="center", va="bottom",
                xytext=(HUB_CENTER_X + 1.0, HUB_CENTER_Y),
                arrowprops=dict(arrowstyle="->", color="#ff6b35", lw=1))

    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches="tight", facecolor=DARK_BG)
    print(f"  Saved: {out_path}")
    if show:
        plt.show()
    plt.close()


def print_summary(df: pd.DataFrame, grid: pd.DataFrame):
    """Print shooting profile summary stats useful for tuning."""
    print("\n=== Shooting Profile Summary ===")
    print(f"Field positions with scoring solutions: {len(grid):,}")
    print(f"\nOptimal velocity (min that scores) by distance band:")
    bands = [(0, 2), (2, 4), (4, 6), (6, 8), (8, 10), (10, 15)]
    print(f"  {'Distance':>12}  {'Min Vel':>10}  {'Opt Angle':>10}  {'Positions':>10}")
    for lo, hi in bands:
        band = grid[(grid["distance"] >= lo) & (grid["distance"] < hi)]
        if len(band) == 0:
            continue
        med_vel = band["min_vel"].median()
        med_ang = band["opt_angle"].median()
        print(f"  {lo:.0f}â€“{hi:.0f} m      {med_vel:>8.1f}   {med_ang:>8.1f}Â°   {len(band):>10}")

    print(f"\nSuggested InterpolatingDoubleTreeMap entries for RobotMap:")
    print(f"  // kShootingVelocityMap (distance_m â†’ velocity_mps)")
    for lo, hi in bands:
        band = grid[(grid["distance"] >= lo) & (grid["distance"] < hi)]
        if len(band) == 0:
            continue
        med_dist = band["distance"].median()
        min_vel  = band["min_vel"].median()
        print(f"  Map.entry({med_dist:.1f}, {min_vel:.1f}),")

    print(f"\n  // kShootingPositionMap (distance_m â†’ hood_angle_turns)")
    for lo, hi in bands:
        band = grid[(grid["distance"] >= lo) & (grid["distance"] < hi)]
        if len(band) == 0:
            continue
        med_dist  = band["distance"].median()
        med_angle = band["opt_angle"].median()
        angle_turns = med_angle / 360.0
        print(f"  Map.entry({med_dist:.1f}, {angle_turns:.4f}),  // {med_angle:.1f}Â°")


def main():
    parser = argparse.ArgumentParser(description="Shooter Profile 3D Map Visualizer")
    parser.add_argument("csv", nargs="?", default="shooter_profile.csv",
                        help="Path to shooter_profile.csv (default: ./shooter_profile.csv)")
    parser.add_argument("--no-show", action="store_true",
                        help="Skip interactive plot window (just save PNGs)")
    args = parser.parse_args()

    csv_path = args.csv
    if not os.path.isfile(csv_path):
        print(f"ERROR: CSV not found at '{csv_path}'")
        print("  Run  ./gradlew runProfiler  first to generate the CSV.")
        sys.exit(1)

    show = not args.no_show
    out_dir = os.path.dirname(os.path.abspath(csv_path))

    # â”€â”€ Load data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    df = load_csv(csv_path)
    if df.empty:
        print("ERROR: CSV is empty â€” no successful shots found. Check ShooterProfiler configuration.")
        sys.exit(1)

    # â”€â”€ Build per-cell optimal grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    grid = build_grid(df)

    # â”€â”€ Plots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    matplotlib.rcParams.update({
        "font.family": "DejaVu Sans",
        "figure.facecolor": DARK_BG,
        "text.color": TEXT_CLR,
    })

    plot_3d_scatter(
        df,
        out_path=os.path.join(out_dir, "shooter_profile_3d.png"),
        show=show,
    )

    plot_3d_params(
        df,
        out_path=os.path.join(out_dir, "shooter_profile_params_3d.png"),
        show=show,
    )

    plot_2d_heatmap(
        grid, column="min_vel",
        title="Optimal Launch Velocity Heatmap\n(minimum velocity that scores from each field position)",
        cbar_label="Min Launch Velocity (m/s)",
        cmap="plasma",
        out_path=os.path.join(out_dir, "heatmap_velocity.png"),
        show=show,
    )

    plot_2d_heatmap(
        grid, column="opt_angle",
        title="Optimal Hood Angle Heatmap\n(hood angle for minimum-velocity shot from each field position)",
        cbar_label="Hood Angle (degrees)",
        cmap="viridis",
        out_path=os.path.join(out_dir, "heatmap_angle.png"),
        show=show,
    )

    plot_2d_heatmap(
        grid, column="count",
        title="Shot Robustness Heatmap\n(number of angle+velocity combos that score â€” higher = more forgiving position)",
        cbar_label="Successful Combos (count)",
        cmap="YlOrRd",
        out_path=os.path.join(out_dir, "heatmap_count.png"),
        show=show,
    )

    # â”€â”€ Summary (useful for filling in RobotMap InterpolatingDoubleTreeMaps) â”€â”€â”€â”€
    print_summary(df, grid)

    print(f"\nAll outputs saved to: {out_dir}")
    print("  shooter_profile_params_3d.png  â† Velocity vs Angle vs Distance (new!)")
    print("Done! ðŸŽ¯")


if __name__ == "__main__":
    main()
