import Head from 'next/head';
import { Callout } from 'nextra/components';
import { Cards, Card } from 'nextra/components';
import {
    GenericHero,
    GenericWidget,
    GenericGrid,
    GenericTimeline,
    ModernCard
} from '../../../Components/index';

<Head>
    <title>Zero to Hero Episode 2: The Command-Based Framework - FEDS Handbook</title>
    <meta property="og:title" content="Zero to Hero Episode 2: The Command-Based Framework - FEDS Handbook" key="title" />
</Head>

<GenericHero
    title="Zero to Hero #2"
    titleColor="linear-gradient(135deg, #4f46e5 0%, #7c3aed 20%, #a855f7 40%, #c084fc 60%, #e879f9 80%, #f0abfc 100%)"
    subtitle="The Conductor: Command-Based Architecture ğŸ—ï¸"
    description="Welcome to the Architecture phase! In Episode 1, we made a motor spin. In Episode 2, we learn how to organize code so we can make *many* motors spin without losing our minds. We're moving from 'Code Scribbles' to 'Code Blueprints'."
    backgroundType="gradient"
    backgroundValue="linear-gradient(135deg, #1e1b4b 0%, #312e81 15%, #4338ca 30%, #4f46e5 45%, #6366f1 60%, #818cf8 75%, #a5b4fc 90%, #c7d2fe 100%)"
    particles={[
        { symbol: 'ğŸ—ï¸', transform: 'translateX(15px) translateY(-10px)' },
        { symbol: 'ğŸ¼', transform: 'translateX(-12px) translateY(8px)' },
        { symbol: 'ğŸ“¦', transform: 'translateX(8px) translateY(-15px)' }
    ]}
    buttons={[
        { text: 'ğŸ¬ Watch Episode', style: 'primary', href: '#' },
        { text: 'â¬…ï¸ Back to Ep 1', style: 'secondary', href: '/Tutorials/ZeroToHero/ZeroToHero1' }
    ]}
    height="md"
    textAlign="center"
    overlay={{ enabled: true, color: 'rgba(0, 0, 0, 0.1)' }}
/>

<Callout type="info" emoji="ğŸ©">
    **The Conductor Analogy**: Imagine an orchestra.
    * The **Robot** is the Concert Hall.
    * The **Subsystems** (Episode 3) are the musicians (Violin, Drums).
    * The **Commands** (This Episode) are the sheet music telling them *what* to play.
    * The **RobotContainer** is the Conductor, deciding *when* the music starts.
</Callout>

## ğŸ¯ Learning Objectives
<br></br><br></br>
<GenericWidget title="What You'll Master" variant="gradient" size="lg">
    <GenericGrid layout="responsive" columns={{ xs: 1, sm: 2 }} gap="16px" items={[
        { title: "The Architecture", icon: "ğŸ›ï¸", description: "Why we split code into different files instead of one giant file of doom." },
        { title: "RobotContainer", icon: "ğŸ“¦", description: "The brain of the operation: where buttons meet actions." },
        { title: "The Command Lifecycle", icon: "â™»ï¸", description: "Init -> Execute -> End. The circle of life for code." },
        { title: "Triggers & Bindings", icon: "ğŸ®", description: "Making controller buttons actually do stuff." }
    ]}
                 renderItem={(item) => <ModernCard {...item} variant="elevated" size="sm" />}
    />
</GenericWidget>

---

## ğŸ—ï¸ Chapter 1: The Big Picture

### Why "Command-Based"?
In the "Olden Days" (like... 2015), we wrote code in big loops. It was messy. If you wanted the arm to move while the robot drove, you had to write complex `if` statements.

**Command-Based** solves this by letting us write small, isolated pieces of code ("Commands") and the WPILib Scheduler handles running them all at once. It's multi-tasking for free!

### The Three Pillars
1.  **Subsystems**: The physical parts (Drivebase, Arm, Intake). They represent *hardware*.
2.  **Commands**: The actions (DriveForward, RaiseArm, EatPizza). They represent *verbs*.
3.  **RobotContainer**: The glue. It connects the hardware to the actions using controllers.

---

## ğŸ“¦ Chapter 2: The RobotContainer

`RobotContainer.java` is where 90% of your configuration happens. It's not a Subsystem. It's a setup class.

```java
public class RobotContainer {
    // 1. Define Subsystems (The Hardware)
    private final DriveSubsystem m_drive = new DriveSubsystem();
    private final ArmSubsystem m_arm = new ArmSubsystem();

    // 2. Define Controllers (The Input)
    private final CommandXboxController m_driver = new CommandXboxController(0);

    public RobotContainer() {
        // 3. Configure bindings
        configureBindings();

        // 4. Set Default Commands (What to do when no buttons are pressed)
        m_drive.setDefaultCommand(
            // Run command that constantly reads joystick
            new RunCommand(
                () -> m_drive.arcadeDrive(-m_driver.getLeftY(), -m_driver.getRightX()),
                m_drive
            )
        );
    }

    private void configureBindings() {
        // "When A is pressed, print Hello"
        m_driver.a().onTrue(new InstantCommand(() -> System.out.println("Hello!")));
    }
}
```

<Callout type="warning" emoji="âš ï¸">
    **Common Mistake**: Do NOT put game logic in `Robot.java`. `Robot.java` should mostly be empty in Command-Based programming. Treat `RobotContainer` as your main entry point!
</Callout>

---

## ğŸ“œ Chapter 3: Anatomy of a Command

A Command is a class that implements the `Command` interface. It has four main methods that run in a specific order.

<GenericTimeline orientation="vertical" variant="cards" items={[
    { title: "initialize()", description: "Runs ONCE when the command is scheduled. Reset timers, zero sensors, or shout 'Here we go!'", icon: "ğŸš€", date: "Start" },
    { title: "execute()", description: "Runs REPEATEDLY (every 20ms) while the command is active. Update motors, calculate math.", icon: "ğŸ”„", date: "Loop" },
    { title: "isFinished()", description: "Runs REPEATEDLY after execute. Returns true if the command is done (e.g., timer expired, target reached).", icon: "â“", date: "Check" },
    { title: "end(bool interrupted)", description: "Runs ONCE when isFinished returns true OR another command interrupts this one. Stop motors here!", icon: "ğŸ›‘", date: "Stop" }
]}
/>

### Code Example: `DriveDistanceCommand`

```java
public class DriveDistanceCommand extends Command {
    private final DriveSubsystem m_drive;
    private final double m_distance;

    // Constructor: Require the subsystem!
    public DriveDistanceCommand(DriveSubsystem drive, double distance) {
        m_drive = drive;
        m_distance = distance;
        addRequirements(m_drive); // Crucial! Tells scheduler "I need the drivebase"
    }

    @Override
    public void initialize() {
        m_drive.resetEncoders();
    }

    @Override
    public void execute() {
        m_drive.tankDrive(0.5, 0.5); // Drive forward at 50%
    }

    @Override
    public boolean isFinished() {
        // Stop if we passed the distance
        return m_drive.getAverageDistance() >= m_distance;
    }

    @Override
    public void end(boolean interrupted) {
        m_drive.stop(); // Safety first!
    }
}
```

---

## ğŸ® Chapter 4: Triggers & Bindings

This is how we make the robot interactive. In modern WPILib (2024+), we use `Trigger` objects.

### Types of Bindings
* **`onTrue()`**: Runs the command *once* when the button is pressed. (Good for: "Shoot", "Toggle").
* **`whileTrue()`**: Runs the command repeatedly while holding the button. Ends when released. (Good for: "Spin Intake").
* **`onFalse()`**: Runs when the button is *released*.
* **`toggleOnTrue()`**: Press to start, press again to stop.

```java
// In RobotContainer.configureBindings()

// While holding 'X', spin intake. When released, it stops (because command ends).
m_driver.x().whileTrue(new StartIntakeCommand(m_intake));

// When 'A' is pressed, schedule the "Score" command. It runs until it finishes itself.
m_driver.a().onTrue(new ScoreAmpCommand(m_arm, m_shooter));

// Triggers can be anything! Not just buttons!
// "If battery voltage drops below 10V, rumble controller"
new Trigger(() -> RobotController.getBatteryVoltage() < 10)
    .onTrue(new InstantCommand(() -> m_driver.getHID().setRumble(RumbleType.kBothRumble, 1)));
```

---

## ğŸ§  Checkpoint

You now understand the skeleton of a robot program!
1.  **RobotContainer** holds the pieces.
2.  **Commands** are the instructions.
3.  **Triggers** start the instructions.

But... what are they controlling? In **Episode 3**, we will build the Muscles (Subsystems) to make this skeleton move!

---

## ğŸ“ Need Help? We've Got Your Back!

- **Email**: feds.programming@gmail.com

**Keep coding, keep learning, and remember: every expert was once a beginner who refused to give up!** ğŸš€

*P.S. - If your robot starts talking back, that's either very advanced AI or you need more sleep. Probably more sleep.* ğŸ¤–ğŸ’¤

---

*This documentation is part of the Zero to Hero programming series. For the complete learning experience, watch the accompanying video and practice with real robot code. Remember: the only way to get good at programming is to write lots of bad code first! ğŸ˜„*

<Callout type="info" emoji="ğŸ’">
    **Special Thanks**: To all the students who asked "Why doesn't this work?" and inspired us to create better documentation. Your questions make us better teachers, and your curiosity drives innovation. You're the real MVPs! ğŸ†

    *Remember: Every expert was once a beginner who refused to give up. Keep coding, keep learning, and most importantly - keep having fun! ğŸš€*
</Callout>