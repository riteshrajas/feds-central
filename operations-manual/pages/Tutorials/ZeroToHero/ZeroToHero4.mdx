import Head from 'next/head';
import { Callout } from 'nextra/components';
import { GenericHero, GenericWidget, GenericGrid, ModernCard } from '../../../Components/index';

<Head>
    <title>Zero to Hero Episode 4: Sensors & Perception - FEDS Handbook</title>
</Head>

<GenericHero
    title="Zero to Hero #4"
    titleColor="linear-gradient(135deg, #f59e0b 0%, #d97706 100%)"
    subtitle="The Senses: Sensors & Perception üëÅÔ∏è"
    description="A robot without sensors is just a remote-controlled car. To be autonomous, it needs to see, feel, and measure the world. In this episode, we master Encoders, Gyros, and Limit Switches."
    backgroundType="gradient"
    backgroundValue="linear-gradient(135deg, #78350f 0%, #92400e 100%)"
    particles={[
        { symbol: 'üëÅÔ∏è', transform: 'translate(0,0)' },
        { symbol: 'üì°', transform: 'translate(10px,10px)' }
    ]}
    buttons={[
        { text: '‚¨ÖÔ∏è Back to Ep 3', style: 'secondary', href: '/Tutorials/ZeroToHero/ZeroToHero3' }
    ]}
    height="md"
    textAlign="center"
/>

## üéØ The Sensor Arsenal

<GenericWidget title="Types of Sensors" variant="gradient">
    <GenericGrid layout="responsive" columns={{ xs: 1, sm: 3 }} gap="16px" items={[
        { title: "Digital Input", icon: "üîò", description: "True/False. Limit Switches, Beam Breaks." },
        { title: "Encoder", icon: "üìè", description: "How far/fast? Measures rotation." },
        { title: "Gyroscope (IMU)", icon: "üß≠", description: "Rotation/Heading. Which way is North?" }
    ]}
                 renderItem={(item) => <ModernCard {...item} variant="elevated" size="sm" />}
    />
</GenericWidget>

---

## üõë Chapter 1: The Limit Switch (Digital Input)

The humble limit switch. It prevents your elevator from smashing through the ceiling.

```java
// Hardware
DigitalInput m_limitSwitch = new DigitalInput(0); // Plugged into DIO 0

public boolean isAtTop() {
    // Note: Most switches are "Normally Open" (False when not pressed)
    // BUT checking wiring is crucial.
    return m_limitSwitch.get();
}
```

### Debouncing
Sometimes switches flicker (On-Off-On-Off) very fast when hit. You can "debounce" this in software.
```java
Debouncer m_debouncer = new Debouncer(0.1); // Must stay stable for 0.1s

public boolean isPressedStable() {
    return m_debouncer.calculate(m_limitSwitch.get());
}
```

---

## üìè Chapter 2: Encoders

Encoders count rotations.
* **Relative Encoders**: "I moved 50 steps." (Forgot where 0 was when power cut).
* **Absolute Encoders**: "I am at 45 degrees." (Remembers position even when off).

### Using TalonFX Integrated Encoders (Relative)
The TalonFX (Falcon 500 / Kraken) has a built-in encoder.

```java
// Get position in Rotations
double rotations = m_motor.getPosition().getValue();

// Get velocity in Rotations per Second (RPS)
double velocity = m_motor.getVelocity().getValue();
```

### The Math: Rotations to Meters
Robots don't drive in "rotations". They drive in meters or inches.

```java
public double getDistanceMeters() {
    double motorRotations = m_motor.getPosition().getValue();
    double gearRatio = 8.14; // e.g., L2 SDS Module
    double wheelDiameterMeters = Units.inchesToMeters(4);

    double wheelRotations = motorRotations / gearRatio;
    return wheelRotations * (Math.PI * wheelDiameterMeters);
}
```
<Callout type="info" emoji="üí°">
    **Math Tip**: Circumference = Pi * Diameter. Distance = Rotations * Circumference.
</Callout>

---

## üß≠ Chapter 3: The Gyroscope (IMU)

The Gyro tells you your **Heading** (Yaw). Essential for Field-Oriented Drive.
Common Gyros: Pigeon 2.0, NavX.

```java
Pigeon2 m_gyro = new Pigeon2(0, "rio");

public double getHeadingDegrees() {
    // Returns continuous angle (0, 360, 720...)
    return m_gyro.getYaw().getValue();
}

public Rotation2d getRotation2d() {
    // Returns -180 to 180 degrees standardized
    return m_gyro.getRotation2d();
}

public void resetHeading() {
    m_gyro.setYaw(0);
}
```

### Why Field-Oriented Drive?
If the robot spins 90 degrees, "Forward" on the joystick should still move the robot away from the driver, not "Robot Forward". You need a Gyro to do the math to rotate the joystick inputs!

---

## üèÅ Summary

Now your robot can:
1.  **Feel** walls (Limit Switches).
2.  **Measure** distance (Encoders).
3.  **Know** direction (Gyros).

But knowing where you are isn't enough. You need to know how to *get* to where you want to go. That requires **PID Control**, the topic of **Episode 5**!

---

## üìû Need Help? We've Got Your Back!

- **Email**: feds.programming@gmail.com

**Keep coding, keep learning, and remember: every expert was once a beginner who refused to give up!** üöÄ

*P.S. - If your robot starts talking back, that's either very advanced AI or you need more sleep. Probably more sleep.* ü§ñüí§

---

*This documentation is part of the Zero to Hero programming series. For the complete learning experience, watch the accompanying video and practice with real robot code. Remember: the only way to get good at programming is to write lots of bad code first! üòÑ*

<Callout type="info" emoji="üíù">
    **Special Thanks**: To all the students who asked "Why doesn't this work?" and inspired us to create better documentation. Your questions make us better teachers, and your curiosity drives innovation. You're the real MVPs! üèÜ

    *Remember: Every expert was once a beginner who refused to give up. Keep coding, keep learning, and most importantly - keep having fun! üöÄ*
</Callout>